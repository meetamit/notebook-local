<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <link type="text/css" rel="stylesheet" href="/assets/notebook-inspector-style.css" >
    <link type="text/css" rel="stylesheet" href="/assets/style.css" >
    <script src="/assets/d3-selection.min.js"></script>
  </head>
  <body>
    <div id='messages'></div>
    <div id='notebook'></div>
    <script type='module'>
      import { Runtime   } from '/assets/notebook-runtime.js'
      import { Library   } from '/assets/notebook-stdlib.js'
      import { Inspector } from '/assets/notebook-inspector.js' // 'https://unpkg.com/@observablehq/notebook-inspector@1.1.4/dist/notebook-inspector.js'
      const d3 = window.d3

      const notebookName = (/\/run\/(?<file>[^.]*)(\.js)?/).exec(location.pathname).groups.file
      const runtime = new Runtime(new Library)
      const impl = d3.local()
      const viewstate = d3.local()

      connectWebSocket()
      syncNotebook()

      async function connectWebSocket() {
        const ws = new WebSocket(await (await fetch('/socket')).text())
        ws.onmessage = function (message) {
          const { event, filename } = JSON.parse(message.data)
          if (event === 'update' && filename === notebookName) {
            syncNotebook()
          }
        }
      }

      async function syncNotebook() {
        let notebook, states
        const notebookPath = `/notebooks/${notebookName}.js`
        try {
          notebook = ( await import(`${notebookPath}?${Date.now()}`) ).default
          await resolveExternalImports(notebook, d3.select('#notebook').datum())
          states = await fetch(`/notebook-views/${notebookName}.json?${Date.now()}`)
          states = states.ok ? await states.json() : null
          update(notebook, states)
          document.querySelector('#messages').innerHTML = ''
        } catch (e) {
          console.log('Error Caught: ', e)
          document.querySelector('#messages').innerHTML = `
            <div style='padding: 40px'>
              <h1>Error</h1>
              <h3>Could not import notebook <a href=${notebookPath}>${notebookPath}</a>:</h3>
              <p style="color: #e7040f;">${e}</p>
            </div>
          `
        }
      }

      async function resolveExternalImports(notebook, prevNotebook) {
        const externals = new Set()
        notebook.modules.forEach(m => {
          m.variables.forEach(v => {
            if (v.from && (v.from.charAt(0) === '/' || v.from.match(/^https?:\/\//))) {
              externals.add(v.from)
            }
          })
        })
        for (let external of externals) {
          if (notebook.modules.find(m => m.id === external)) {
            // external is actually embedded in notebook, so do nothing
            console.log('actually have', external)
          } else if (prevNotebook && prevNotebook.modules.find(m => m.id === external)) {
            // external is available in the previous notebook and can be copied over
            prevNotebook.modules.forEach(m => {
              if (m.id === external) {
                notebook.modules.push(m)
                console.log('add old', m)
              }
            })
          } else {
            // external must be imported
            console.log('importing', external)
            const remoteNotebook = (await import(external)).default
            console.log('remoteNotebook',remoteNotebook)
            remoteNotebook.modules.forEach(m => {
              notebook.modules.push({...m, external: external, id: m.id === remoteNotebook.id ? external : m.id})
              console.log('add remote', m)
            })
          }
        }
      }

      async function syncView(notebook, states) {
        const state = { modules:[] }
        d3.select('#notebook').selectAll('.module')
          .each(function(m) {
            if (m.id !== notebook.id) { return }
            const module = { id:m.id, variables:[] }
            state.modules.push(module)
            d3.select(this).selectAll('.variable')
              .each(function(v) {
                module.variables.push(viewstate.get(this))
              })
          })
        update(notebook, states)
        await fetch(`/notebook-views/${notebookName}.json`, {
          method: 'POST',
          headers: { "Content-Type": "application/json; charset=utf-8", },
          body: JSON.stringify(state),
        })
      }
      function update(notebook, states) {
        let module = d3.select('#notebook').datum(notebook).selectAll('div.module')
          .data(notebook.modules, d => d.id)
        module.exit().remove()
        module.enter()
          .append('div').attr('class', 'module')
          .each(function(m) { impl.set(this, runtimeModule(m.id)) })
        .merge(module)
          .style('display', m => m.id === notebook.id ? null : 'none')
          .each(function (m, i) {
            const mImpl = impl.get(this)
            let variable = d3.select(this).selectAll('div.variable')
              .data(d => d.variables, comparable)

            variable.enter()
              .append('div').attr('class', 'variable')
              .each(function (v, j) {
                const state = (states && states.modules[i] && states.modules[i].variables[j]) || {
                  title: true,
                  value: true,
                  code: false,
                }
                viewstate.set(this, state)

                const sel = d3.select(this)
                sel.append('pre').attr('class', 'title')
                  .text(v.name ? v.name + ':' : null)
                const inspector = sel.append('div').attr('class', 'inspector')
                sel.append('pre').attr('class', 'code')
                  .text(v.value ? formatValue(v.value) : null)

                const controls = sel.append('div').attr('class', 'controls')
                controls.append('div')
                  .attr('class', 'show-title circle-button')
                  .attr('title', 'Show/Hide Name')
                  .on('click', () => {
                    state.title = !state.title
                    syncView(notebook)
                  })
                controls.append('div')
                  .attr('class', 'show-value circle-button')
                  .on('click', () => {
                    state.value = !state.value
                    syncView(notebook)
                  })
                controls.append('div')
                  .attr('class', 'show-code circle-button')
                  .attr('title', 'Show/Hide Code')
                  .on('click', () => {
                    state.code = !state.code
                    syncView(notebook)
                  })

                const vImpl = mImpl.variable(
                  m.id === notebook.id ? new Inspector(inspector.node()) : null
                )

                if (v.from) {
                  vImpl.import(v.remote, v.name, runtimeModule(v.from))
                } else {
                  vImpl.define(v.name, v.inputs, v.value)
                }
                impl.set(this, vImpl)

                controls.append('div')
                  .attr('class', 'rerun circle-button')
                  .attr('title', 'Re-run cell')
                  .on('click', function() {
                    // re-run by redefining the variable
                    if (v.from) {
                      vImpl.import(v.remote, v.name, runtimeModule(v.from))
                    } else {
                      vImpl.define(v.name, v.inputs, v.value)
                    }
                  })
              })
            .merge(variable)
              .order()
              .each(function (v, j) {
                let state = viewstate.get(this)
                const hidden = !state.value
                const sel = d3.select(this)
                  .classed('hidden', hidden)

                sel.select('.title')
                  .style('display', hidden || !state.title || !v.name ? 'none' : null)
                sel.select('.inspector')
                  .style('display', hidden ? 'none' : null)
                sel.select('.code')
                  .style('display', hidden || !state.code ? 'none' : null)

                sel.select('.show-title')
                  .classed('off', !state.title)
                  .style('display', hidden || !v.name ? 'none' : null)
                sel.select('.show-value')
                  .attr('title', `Show Cell ${hidden ? v.name : ''}"`)
                  .attr('title', hidden && v.name ? `Show Cell "${v.name}"` : 'Show/Hide Cell')
                  .classed('off', hidden)
                sel.select('.show-code')
                  .classed('off', !state.code)
                  .style('display', hidden || !v.value ? 'none' : null)
                sel.select('.rerun')
                  .style('display', hidden ? 'none' : null)

              })

            variable.exit()
              .each(function (v) { impl.get(this).delete() })
              .remove()
          })
      }

      function runtimeModule(id) {
        const map = runtimeModule.map || (runtimeModule.map = new Map)
        let module = map.get(id);
        if (!module) map.set(id, module = runtime.module());
        return module;
      }

      function comparable(o) {
        return JSON.stringify(Object.keys(o).reduce((m, k) => {
          if (typeof o[k] === 'function') {
            m[k] = String(o[k])
          } else {
            m[k] = o[k]
          }
          return m
        }, {}))
      }

      function formatValue(value) {
        if (typeof value === 'function') {
          let lines = value.toString().split('\n')
          const lastIndent = lines[lines.length - 1]
            .match(/^\s*/)[0]
          lines = lines.map(l => l.replace(lastIndent, ''))
          return lines.join('\n')
        } else {
          return JSON.stringify(value)
        }
      }
    </script>
  </body>
</html>
